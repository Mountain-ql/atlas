Index: libavcodec/avcodec.h
===================================================================
--- libavcodec/avcodec.h	(revision 25549)
+++ libavcodec/avcodec.h	(working copy)
@@ -2744,6 +2744,93 @@
      * - decoding: unused
      */
     int lpc_passes;
+	
+    /* callback for external slice processing */
+    void (*process_slice)(void *);
+    /* callback for sideband data processing */
+    void (*process_sideband)(const uint8_t *);
+    /* callback for external macroblock processing */
+    void (*process_mb)(void *);
+
+    /* NALU type number for our custom sideband data NALUs */
+#define NAL_SIDEBAND_DATA   0x1F
+    /* pseudo slices */
+#define PSEUDO_SLICE_FRAME_START  -1
+#define PSEUDO_SLICE_FRAME_END    -2
+
+    /* the metrics for the decoding time estimation */
+    /* toggle metrics extraction */
+#define FFMPEG_METRICS 1
+#if FFMPEG_METRICS
+#  define FFMPEG_METRICS_EXTRACT(x) x
+#else
+#  define FFMPEG_METRICS_EXTRACT(x)
+#endif
+    struct {
+        int type;
+        int bits;
+        int intra_pcm;
+        int intra_4x4;
+        int intra_8x8;
+        int intra_16x16;
+        int inter_4x4;
+        int inter_8x8;
+        int inter_16x16;
+        int idct_4x4;
+        int idct_8x8;
+        int deblock_edges;
+    } metrics;
+
+    /* time measurements */
+    /* toggle time measurement */
+#define FFMPEG_TIME 0
+#if FFMPEG_TIME
+#  define FFMPEG_TIME_START(context,slot) context->timing.slot -= read_time()
+#  define FFMPEG_TIME_STOP(context,slot) context->timing.slot += read_time()
+#else
+#  define FFMPEG_TIME_START(context,slot)
+#  define FFMPEG_TIME_STOP(context,slot)
+#endif
+    struct {
+        uint64_t decoder_prep;      /* cabac init */
+        uint64_t decompress_cabac;  /* decode_mb_cabac, includes iscan and iquant */
+        uint64_t decompress_cavlc;  /* decode_mb_cavlc, includes iscan and iquant */
+        uint64_t spatial_pred;      /* pred4x4, pred8x8, pred8x8l, pred16x16 */
+        uint64_t temporal_pred;     /* hl_motion */
+        uint64_t idct;              /* idct and merge */
+        uint64_t post;              /* xchg_mb_border, filter_mb */
+        uint64_t frame_end;         /* execute_ref_pic_marking, ff_er_frame_end, MPV_frame_end */
+        uint64_t total;
+    } timing;
+
+    /* frame structure */
+    struct {
+        int flag_idr;
+        AVFrame *current;
+        AVFrame *display;
+        int mb_width;
+        int mb_height;
+    } frame;
+
+    /* slice structure; does not support FMO */
+    struct {
+        int flag_last;
+        int start_index;  /* macroblock numbers, start inclusive, end exclusive */
+        int end_index;
+        int skip;         /* in-parameter to skip the next slice */
+        int conceal;      /* in-parameter to activate FFmpeg's error concealment */
+    } slice;
+
+    /* reference structure */
+    struct {
+        int long_count;
+        int short_count;
+        AVFrame *long_list[32];
+        AVFrame *short_list[32];
+        int count[2];
+        AVFrame *list[2][32];
+    } reference;
+
 } AVCodecContext;
 
 /**
Index: libavcodec/h264.c
===================================================================
--- libavcodec/h264.c	(revision 25549)
+++ libavcodec/h264.c	(working copy)
@@ -60,6 +60,18 @@
     PIX_FMT_NONE
 };
 
+FFMPEG_METRICS_EXTRACT(static int *inter_type);
+static const int qpel_luma_cost[] = {
+    1, 10,  6, 10,
+    10,  6,  7,  6,
+    6,  7,  6,  7,
+    10,  6,  7,  6
+};
+static const int qpel_chroma_cost[] = {
+    2, 4, 8
+};
+
+
 void ff_h264_write_back_intra_pred_mode(H264Context *h){
     int8_t *mode= h->intra4x4_pred_mode + h->mb2br_xy[h->mb_xy];
 
@@ -402,7 +414,9 @@
             src_y= s->edge_emu_buffer + 2 + 2*h->mb_linesize;
         emu=1;
     }
-
+	
+    FFMPEG_METRICS_EXTRACT(*inter_type += (1 + !square) * (qpel_luma_cost[luma_xy] + qpel_chroma_cost[!!(mx&7)+!!(my&7)]));
+	
     qpix_op[luma_xy](dest_y, src_y, h->mb_linesize); //FIXME try variable height perhaps?
     if(!square){
         qpix_op[luma_xy](dest_y + delta, src_y + delta, h->mb_linesize);
@@ -579,11 +593,13 @@
     prefetch_motion(h, 0);
 
     if(IS_16X16(mb_type)){
+        FFMPEG_METRICS_EXTRACT(inter_type = &s->avctx->metrics.inter_16x16);
         mc_part(h, 0, 1, 8, 0, dest_y, dest_cb, dest_cr, 0, 0,
                 qpix_put[0], chroma_put[0], qpix_avg[0], chroma_avg[0],
                 weight_op, weight_avg,
                 IS_DIR(mb_type, 0, 0), IS_DIR(mb_type, 0, 1));
     }else if(IS_16X8(mb_type)){
+        FFMPEG_METRICS_EXTRACT(inter_type = &s->avctx->metrics.inter_8x8);
         mc_part(h, 0, 0, 4, 8, dest_y, dest_cb, dest_cr, 0, 0,
                 qpix_put[1], chroma_put[0], qpix_avg[1], chroma_avg[0],
                 &weight_op[1], &weight_avg[1],
@@ -593,6 +609,7 @@
                 &weight_op[1], &weight_avg[1],
                 IS_DIR(mb_type, 1, 0), IS_DIR(mb_type, 1, 1));
     }else if(IS_8X16(mb_type)){
+        FFMPEG_METRICS_EXTRACT(inter_type = &s->avctx->metrics.inter_8x8);
         mc_part(h, 0, 0, 8, 8*h->mb_linesize, dest_y, dest_cb, dest_cr, 0, 0,
                 qpix_put[1], chroma_put[1], qpix_avg[1], chroma_avg[1],
                 &weight_op[2], &weight_avg[2],
@@ -613,11 +630,13 @@
             int y_offset= (i&2)<<1;
 
             if(IS_SUB_8X8(sub_mb_type)){
+                FFMPEG_METRICS_EXTRACT(inter_type = &s->avctx->metrics.inter_8x8);
                 mc_part(h, n, 1, 4, 0, dest_y, dest_cb, dest_cr, x_offset, y_offset,
                     qpix_put[1], chroma_put[1], qpix_avg[1], chroma_avg[1],
                     &weight_op[3], &weight_avg[3],
                     IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1));
             }else if(IS_SUB_8X4(sub_mb_type)){
+                FFMPEG_METRICS_EXTRACT(inter_type = &s->avctx->metrics.inter_4x4);
                 mc_part(h, n  , 0, 2, 4, dest_y, dest_cb, dest_cr, x_offset, y_offset,
                     qpix_put[2], chroma_put[1], qpix_avg[2], chroma_avg[1],
                     &weight_op[4], &weight_avg[4],
@@ -627,6 +646,7 @@
                     &weight_op[4], &weight_avg[4],
                     IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1));
             }else if(IS_SUB_4X8(sub_mb_type)){
+                FFMPEG_METRICS_EXTRACT(inter_type = &s->avctx->metrics.inter_4x4);
                 mc_part(h, n  , 0, 4, 4*h->mb_linesize, dest_y, dest_cb, dest_cr, x_offset, y_offset,
                     qpix_put[2], chroma_put[2], qpix_avg[2], chroma_avg[2],
                     &weight_op[5], &weight_avg[5],
@@ -638,6 +658,7 @@
             }else{
                 int j;
                 assert(IS_SUB_4X4(sub_mb_type));
+                FFMPEG_METRICS_EXTRACT(inter_type = &s->avctx->metrics.inter_4x4);
                 for(j=0; j<4; j++){
                     int sub_x_offset= x_offset + 2*(j&1);
                     int sub_y_offset= y_offset +   (j&2);
@@ -1156,6 +1177,7 @@
     }
 
     if (!simple && IS_INTRA_PCM(mb_type)) {
+        FFMPEG_METRICS_EXTRACT(s->avctx->metrics.intra_pcm++);
         for (i=0; i<16; i++) {
             memcpy(dest_y + i*  linesize, h->mb       + i*8, 16);
         }
@@ -1165,17 +1187,22 @@
         }
     } else {
         if(IS_INTRA(mb_type)){
+            FFMPEG_TIME_START(s->avctx, post);
             if(h->deblocking_filter)
                 xchg_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, 1, simple);
+            FFMPEG_TIME_STOP(s->avctx, post);
 
             if(simple || !CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){
+                FFMPEG_TIME_START(s->avctx, spatial_pred);
                 h->hpc.pred8x8[ h->chroma_pred_mode ](dest_cb, uvlinesize);
                 h->hpc.pred8x8[ h->chroma_pred_mode ](dest_cr, uvlinesize);
+                FFMPEG_TIME_STOP(s->avctx, spatial_pred);
             }
 
             if(IS_INTRA4x4(mb_type)){
                 if(simple || !s->encoding){
                     if(IS_8x8DCT(mb_type)){
+                        FFMPEG_METRICS_EXTRACT(s->avctx->metrics.intra_8x8++);
                         if(transform_bypass){
                             idct_dc_add =
                             idct_add    = s->dsp.add_pixels8;
@@ -1187,18 +1214,25 @@
                             uint8_t * const ptr= dest_y + block_offset[i];
                             const int dir= h->intra4x4_pred_mode_cache[ scan8[i] ];
                             if(transform_bypass && h->sps.profile_idc==244 && dir<=1){
+                                FFMPEG_TIME_START(s->avctx, spatial_pred);
                                 h->hpc.pred8x8l_add[dir](ptr, h->mb + i*16, linesize);
+                                FFMPEG_TIME_STOP(s->avctx, spatial_pred);
                             }else{
                                 const int nnz = h->non_zero_count_cache[ scan8[i] ];
+                                FFMPEG_TIME_START(s->avctx, spatial_pred);
                                 h->hpc.pred8x8l[ dir ](ptr, (h->topleft_samples_available<<i)&0x8000,
                                                             (h->topright_samples_available<<i)&0x4000, linesize);
+                                FFMPEG_TIME_STOP(s->avctx, spatial_pred);
+                                FFMPEG_TIME_START(s->avctx, idct);
                                 if(nnz){
+                                    FFMPEG_METRICS_EXTRACT(transform_bypass ? 0 : s->avctx->metrics.idct_8x8++);
                                     if(nnz == 1 && h->mb[i*16])
                                         idct_dc_add(ptr, h->mb + i*16, linesize);
                                     else
                                         idct_add   (ptr, h->mb + i*16, linesize);
                                 }
-                            }
+								FFMPEG_TIME_STOP(s->avctx, idct);
+							}
                         }
                     }else{
                         if(transform_bypass){
@@ -1208,13 +1242,16 @@
                             idct_dc_add = h->h264dsp.h264_idct_dc_add;
                             idct_add    = h->h264dsp.h264_idct_add;
                         }
-                        for(i=0; i<16; i++){
+						FFMPEG_METRICS_EXTRACT(s->avctx->metrics.intra_4x4++);
+						for(i=0; i<16; i++){
                             uint8_t * const ptr= dest_y + block_offset[i];
                             const int dir= h->intra4x4_pred_mode_cache[ scan8[i] ];
 
                             if(transform_bypass && h->sps.profile_idc==244 && dir<=1){
-                                h->hpc.pred4x4_add[dir](ptr, h->mb + i*16, linesize);
-                            }else{
+								FFMPEG_TIME_START(s->avctx, spatial_pred);
+								h->hpc.pred4x4_add[dir](ptr, h->mb + i*16, linesize);
+								FFMPEG_TIME_STOP(s->avctx, spatial_pred);
+							}else{
                                 uint8_t *topright;
                                 int nnz, tr;
                                 if(dir == DIAG_DOWN_LEFT_PRED || dir == VERT_LEFT_PRED){
@@ -1228,10 +1265,14 @@
                                 }else
                                     topright= NULL;
 
-                                h->hpc.pred4x4[ dir ](ptr, topright, linesize);
+								FFMPEG_TIME_START(s->avctx, spatial_pred);
+								h->hpc.pred4x4[ dir ](ptr, topright, linesize);
+                                FFMPEG_TIME_STOP(s->avctx, spatial_pred);
+                                FFMPEG_TIME_START(s->avctx, idct);
                                 nnz = h->non_zero_count_cache[ scan8[i] ];
                                 if(nnz){
                                     if(is_h264){
+                                        FFMPEG_METRICS_EXTRACT(transform_bypass ? 0 : s->avctx->metrics.idct_4x4++);
                                         if(nnz == 1 && h->mb[i*16])
                                             idct_dc_add(ptr, h->mb + i*16, linesize);
                                         else
@@ -1239,25 +1280,35 @@
                                     }else
                                         ff_svq3_add_idct_c(ptr, h->mb + i*16, linesize, s->qscale, 0);
                                 }
+                                FFMPEG_TIME_STOP(s->avctx, idct);
                             }
                         }
                     }
                 }
             }else{
+                FFMPEG_METRICS_EXTRACT(s->avctx->metrics.intra_16x16++);
+                FFMPEG_TIME_START(s->avctx, spatial_pred);
                 h->hpc.pred16x16[ h->intra16x16_pred_mode ](dest_y , linesize);
+                FFMPEG_TIME_STOP(s->avctx, spatial_pred);
+                FFMPEG_TIME_START(s->avctx, idct);
                 if(is_h264){
                     if(!transform_bypass)
                         h264_luma_dc_dequant_idct_c(h->mb, s->qscale, h->dequant4_coeff[0][s->qscale][0]);
                 }else
                     ff_svq3_luma_dc_dequant_idct_c(h->mb, s->qscale);
+                FFMPEG_TIME_STOP(s->avctx, idct);
             }
+            FFMPEG_TIME_START(s->avctx, post);
             if(h->deblocking_filter)
                 xchg_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, 0, simple);
+            FFMPEG_TIME_STOP(s->avctx, post);
         }else if(is_h264){
+            FFMPEG_TIME_START(s->avctx, temporal_pred);
             hl_motion(h, dest_y, dest_cb, dest_cr,
                       s->me.qpel_put, s->dsp.put_h264_chroma_pixels_tab,
                       s->me.qpel_avg, s->dsp.avg_h264_chroma_pixels_tab,
                       h->h264dsp.weight_h264_pixels_tab, h->h264dsp.biweight_h264_pixels_tab);
+            FFMPEG_TIME_STOP(s->avctx, temporal_pred);
         }
 
 
@@ -1266,31 +1317,45 @@
                 if(IS_INTRA16x16(mb_type)){
                     if(transform_bypass){
                         if(h->sps.profile_idc==244 && (h->intra16x16_pred_mode==VERT_PRED8x8 || h->intra16x16_pred_mode==HOR_PRED8x8)){
+                            FFMPEG_METRICS_EXTRACT(s->avctx->metrics.intra_16x16++);
+                            FFMPEG_TIME_START(s->avctx, spatial_pred);
                             h->hpc.pred16x16_add[h->intra16x16_pred_mode](dest_y, block_offset, h->mb, linesize);
+                            FFMPEG_TIME_STOP(s->avctx, spatial_pred);
                         }else{
+                            FFMPEG_TIME_START(s->avctx, idct);
                             for(i=0; i<16; i++){
                                 if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16])
                                     s->dsp.add_pixels4(dest_y + block_offset[i], h->mb + i*16, linesize);
                             }
+                            FFMPEG_TIME_STOP(s->avctx, idct);
                         }
                     }else{
+                        FFMPEG_METRICS_EXTRACT(s->avctx->metrics.idct_4x4 += 16);
+                        FFMPEG_TIME_START(s->avctx, idct);
                          h->h264dsp.h264_idct_add16intra(dest_y, block_offset, h->mb, linesize, h->non_zero_count_cache);
+                        FFMPEG_TIME_STOP(s->avctx, idct);
                     }
                 }else if(h->cbp&15){
                     if(transform_bypass){
                         const int di = IS_8x8DCT(mb_type) ? 4 : 1;
                         idct_add= IS_8x8DCT(mb_type) ? s->dsp.add_pixels8 : s->dsp.add_pixels4;
+                        FFMPEG_TIME_START(s->avctx, idct);
                         for(i=0; i<16; i+=di){
                             if(h->non_zero_count_cache[ scan8[i] ]){
                                 idct_add(dest_y + block_offset[i], h->mb + i*16, linesize);
                             }
                         }
+                        FFMPEG_TIME_STOP(s->avctx, idct);
                     }else{
+                        FFMPEG_TIME_START(s->avctx, idct);
                         if(IS_8x8DCT(mb_type)){
+                            FFMPEG_METRICS_EXTRACT(s->avctx->metrics.idct_8x8 += 4);
                             h->h264dsp.h264_idct8_add4(dest_y, block_offset, h->mb, linesize, h->non_zero_count_cache);
                         }else{
+                            FFMPEG_METRICS_EXTRACT(s->avctx->metrics.idct_4x4 += 16);
                             h->h264dsp.h264_idct_add16(dest_y, block_offset, h->mb, linesize, h->non_zero_count_cache);
                         }
+                        FFMPEG_TIME_STOP(s->avctx, idct);
                     }
                 }
             }else{
@@ -1307,22 +1372,29 @@
             uint8_t *dest[2] = {dest_cb, dest_cr};
             if(transform_bypass){
                 if(IS_INTRA(mb_type) && h->sps.profile_idc==244 && (h->chroma_pred_mode==VERT_PRED8x8 || h->chroma_pred_mode==HOR_PRED8x8)){
+                    FFMPEG_TIME_START(s->avctx, spatial_pred);
                     h->hpc.pred8x8_add[h->chroma_pred_mode](dest[0], block_offset + 16, h->mb + 16*16, uvlinesize);
                     h->hpc.pred8x8_add[h->chroma_pred_mode](dest[1], block_offset + 20, h->mb + 20*16, uvlinesize);
+                    FFMPEG_TIME_STOP(s->avctx, spatial_pred);
                 }else{
                     idct_add = s->dsp.add_pixels4;
+                    FFMPEG_TIME_START(s->avctx, idct);
                     for(i=16; i<16+8; i++){
                         if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16])
                             idct_add   (dest[(i&4)>>2] + block_offset[i], h->mb + i*16, uvlinesize);
                     }
+                    FFMPEG_TIME_STOP(s->avctx, idct);
                 }
             }else{
                 chroma_dc_dequant_idct_c(h->mb + 16*16, h->chroma_qp[0], h->dequant4_coeff[IS_INTRA(mb_type) ? 1:4][h->chroma_qp[0]][0]);
                 chroma_dc_dequant_idct_c(h->mb + 16*16+4*16, h->chroma_qp[1], h->dequant4_coeff[IS_INTRA(mb_type) ? 2:5][h->chroma_qp[1]][0]);
                 if(is_h264){
+                    FFMPEG_METRICS_EXTRACT(s->avctx->metrics.idct_4x4 += 8);
+                    FFMPEG_TIME_START(s->avctx, idct);
                     h->h264dsp.h264_idct_add8(dest, block_offset,
                                               h->mb, uvlinesize,
                                               h->non_zero_count_cache);
+                    FFMPEG_TIME_STOP(s->avctx, idct);
                 }else{
                     for(i=16; i<16+8; i++){
                         if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16]){
@@ -2467,6 +2539,7 @@
     const int end_mb_y= s->mb_y + FRAME_MBAFF;
     const int old_slice_type= h->slice_type;
 
+    FFMPEG_TIME_START(s->avctx, post);
     if(h->deblocking_filter) {
         for(mb_x= 0; mb_x<s->mb_width; mb_x++){
             for(mb_y=end_mb_y - FRAME_MBAFF; mb_y<= end_mb_y; mb_y++){
@@ -2512,6 +2585,8 @@
             }
         }
     }
+    FFMPEG_TIME_STOP(s->avctx, post);
+	
     h->slice_type= old_slice_type;
     s->mb_x= 0;
     s->mb_y= end_mb_y - FRAME_MBAFF;
@@ -2534,7 +2609,49 @@
     H264Context *h = *(void**)arg;
     MpegEncContext * const s = &h->s;
     const int part_mask= s->partitioned_frame ? (AC_END|AC_ERROR) : 0x7F;
+    FFMPEG_METRICS_EXTRACT(unsigned bits_gone_by = 0);
 
+	/* new slice coming up, process previous one */
+	s->avctx->frame.flag_idr  = (h->nal_unit_type == NAL_IDR_SLICE);
+    s->avctx->frame.current   = (AVFrame *)&s->current_picture;
+	s->avctx->frame.mb_width  = s->mb_width;
+	s->avctx->frame.mb_height = s->mb_height;
+	s->avctx->slice.end_index = s->mb_x + s->mb_y * s->mb_width;
+	s->avctx->reference.long_count  = h->long_ref_count;
+	s->avctx->reference.short_count = h->short_ref_count;
+	memcpy(s->avctx->reference.long_list , h->long_ref , sizeof(h->long_ref ));
+	memcpy(s->avctx->reference.short_list, h->short_ref, sizeof(h->short_ref));
+	if (s->avctx->slice.skip && !s->avctx->slice.conceal)
+		/* previous slice has been skipped, mark it done so that error resilience does not kick in */
+        ff_er_add_slice(s,
+						s->avctx->slice.start_index % s->mb_width,
+						s->avctx->slice.start_index / s->mb_width,
+						s->avctx->slice.end_index % s->mb_width - 1,
+						s->avctx->slice.end_index / s->mb_width,
+						(AC_END|DC_END|MV_END) & 0x7F);
+    if (avctx->process_slice) {
+        emms_c();
+        avctx->process_slice(s->avctx);
+    }
+    /* prepare data for upcoming slice */
+    s->avctx->metrics.type = h->slice_type;
+	s->avctx->slice.start_index = s->mb_x + s->mb_y * s->mb_width;
+	s->avctx->reference.count[0] = h->ref_count[0];
+	s->avctx->reference.count[1] = h->ref_count[1];
+    {
+        int i;
+        for (i = 0; i < 32; i++) {
+            s->avctx->reference.list[0][i] = (AVFrame *)&h->ref_list[0][i];
+            s->avctx->reference.list[1][i] = (AVFrame *)&h->ref_list[1][i];
+        }
+    }
+    if (s->avctx->slice.skip) {
+		/* do not decode this slice and skip the given amount of macroblocks */
+		s->mb_x = (s->avctx->slice.start_index + s->avctx->slice.skip) % s->mb_width;
+		s->mb_y = (s->avctx->slice.start_index + s->avctx->slice.skip) / s->mb_width;
+		return 0;
+    }
+    
     s->mb_skip_run= -1;
 
     h->is_complex = FRAME_MBAFF || s->picture_structure != PICT_FRAME || s->codec_id != CODEC_ID_H264 ||
@@ -2545,16 +2662,20 @@
         align_get_bits( &s->gb );
 
         /* init cabac */
+        FFMPEG_TIME_START(s->avctx, decoder_prep);
         ff_init_cabac_states( &h->cabac);
         ff_init_cabac_decoder( &h->cabac,
                                s->gb.buffer + get_bits_count(&s->gb)/8,
                                (get_bits_left(&s->gb) + 7)/8);
 
         ff_h264_init_cabac_states(h);
+        FFMPEG_TIME_STOP(s->avctx, decoder_prep);
 
         for(;;){
 //START_TIMER
+            FFMPEG_TIME_START(s->avctx, decompress_cabac);
             int ret = ff_h264_decode_mb_cabac(h);
+            FFMPEG_TIME_STOP(s->avctx, decompress_cabac);
             int eos;
 //STOP_TIMER("decode_mb_cabac")
 
@@ -2563,13 +2684,26 @@
             if( ret >= 0 && FRAME_MBAFF ) { //FIXME optimal? or let mb_decode decode 16x32 ?
                 s->mb_y++;
 
+                FFMPEG_TIME_START(s->avctx, decompress_cabac);
                 ret = ff_h264_decode_mb_cabac(h);
+                FFMPEG_TIME_STOP(s->avctx, decompress_cabac);
 
                 if(ret>=0) ff_h264_hl_decode_mb(h);
                 s->mb_y--;
             }
+            FFMPEG_TIME_START(s->avctx, decompress_cabac);
             eos = get_cabac_terminate( &h->cabac );
-
+            FFMPEG_TIME_STOP(s->avctx, decompress_cabac);
+            
+            FFMPEG_METRICS_EXTRACT(s->avctx->metrics.bits -= bits_gone_by);
+            FFMPEG_METRICS_EXTRACT(bits_gone_by = (h->cabac.bytestream - h->cabac.bytestream_start) * 8);
+            FFMPEG_METRICS_EXTRACT(s->avctx->metrics.bits += bits_gone_by);
+            
+            if(s->avctx->process_mb) {
+                emms_c();
+                s->avctx->process_mb(s->avctx);
+            }
+			
             if((s->workaround_bugs & FF_BUG_TRUNCATED) && h->cabac.bytestream > h->cabac.bytestream_end + 2){
                 ff_er_add_slice(s, s->resync_mb_x, s->resync_mb_y, s->mb_x-1, s->mb_y, (AC_END|DC_END|MV_END)&part_mask);
                 return 0;
@@ -2601,18 +2735,31 @@
 
     } else {
         for(;;){
+            FFMPEG_TIME_START(s->avctx, decompress_cavlc);
             int ret = ff_h264_decode_mb_cavlc(h);
+            FFMPEG_TIME_STOP(s->avctx, decompress_cavlc);
 
             if(ret>=0) ff_h264_hl_decode_mb(h);
 
             if(ret>=0 && FRAME_MBAFF){ //FIXME optimal? or let mb_decode decode 16x32 ?
                 s->mb_y++;
+                FFMPEG_TIME_START(s->avctx, decompress_cavlc);
                 ret = ff_h264_decode_mb_cavlc(h);
+                FFMPEG_TIME_STOP(s->avctx, decompress_cavlc);
 
                 if(ret>=0) ff_h264_hl_decode_mb(h);
                 s->mb_y--;
             }
-
+            
+            FFMPEG_METRICS_EXTRACT(s->avctx->metrics.bits -= bits_gone_by);
+            FFMPEG_METRICS_EXTRACT(bits_gone_by = get_bits_count(&s->gb));
+            FFMPEG_METRICS_EXTRACT(s->avctx->metrics.bits += bits_gone_by);
+            
+            if(s->avctx->process_mb) {
+                emms_c();
+                s->avctx->process_mb(s->avctx);
+            }
+            
             if(ret<0){
                 av_log(h->s.avctx, AV_LOG_ERROR, "error while decoding MB %d %d\n", s->mb_x, s->mb_y);
                 ff_er_add_slice(s, s->resync_mb_x, s->resync_mb_y, s->mb_x, s->mb_y, (AC_ERROR|DC_ERROR|MV_ERROR)&part_mask);
@@ -2938,7 +3085,13 @@
         case NAL_SPS_EXT:
         case NAL_AUXILIARY_SLICE:
             break;
-        default:
+		case NAL_SIDEBAND_DATA:
+			if (s->avctx->process_sideband) {
+				emms_c();
+				s->avctx->process_sideband(ptr);
+			}
+			break;
+		default:
             av_log(avctx, AV_LOG_DEBUG, "Unknown NAL code: %d (%d bits)\n", hx->nal_unit_type, bit_length);
         }
 
@@ -3011,19 +3164,46 @@
             *pict= *(AVFrame*)out;
         }
 
+        avctx->metrics.type = PSEUDO_SLICE_FRAME_END;
+        avctx->frame.display = *data_size ? pict : NULL;
+        if (avctx->process_slice) {
+            emms_c();
+            avctx->process_slice(avctx);
+        }
+
         return 0;
     }
 
+    avctx->metrics.type = PSEUDO_SLICE_FRAME_START;
+    
     buf_index=decode_nal_units(h, buf, buf_size);
     if(buf_index < 0)
         return -1;
 
+    /* process last slice */
+	s->avctx->slice.flag_last = 1;
+	s->avctx->slice.end_index = s->mb_x + s->mb_y * s->mb_width;
+	if (s->avctx->slice.skip && !s->avctx->slice.conceal)
+		/* previous slice has been skipped, mark it done so that error resilience does not kick in */
+        ff_er_add_slice(s,
+						s->avctx->slice.start_index % s->mb_width,
+						s->avctx->slice.start_index / s->mb_width,
+						s->avctx->slice.end_index % s->mb_width - 1,
+						s->avctx->slice.end_index / s->mb_width,
+						(AC_END|DC_END|MV_END) & 0x7F);
+    if (avctx->process_slice) {
+        emms_c();
+        avctx->process_slice(s->avctx);
+    }
+    avctx->metrics.type = PSEUDO_SLICE_FRAME_END;
+    
     if(!(s->flags2 & CODEC_FLAG2_CHUNKS) && !s->current_picture_ptr){
         if (avctx->skip_frame >= AVDISCARD_NONREF || s->hurry_up) return 0;
         av_log(avctx, AV_LOG_ERROR, "no frame!\n");
         return -1;
     }
 
+    FFMPEG_TIME_START(avctx, frame_end);
     if(!(s->flags2 & CODEC_FLAG2_CHUNKS) || (s->mb_y >= s->mb_height && s->mb_height)){
         Picture *out = s->current_picture_ptr;
         Picture *cur = s->current_picture_ptr;
@@ -3164,10 +3344,19 @@
             }
         }
     }
+    FFMPEG_TIME_STOP(avctx, frame_end);
 
     assert(pict->data[0] || !*data_size);
     ff_print_debug_info(s, pict);
-//printf("out %d\n", (int)pict->data[0]);
+	
+    /* frame end processing */
+    avctx->frame.display = *data_size ? pict : NULL;
+    if (avctx->process_slice) {
+        emms_c();
+        avctx->process_slice(avctx);
+    }
+    
+	//printf("out %d\n", (int)pict->data[0]);
 
     return get_consumed_bytes(s, buf_index, buf_size);
 }
Index: libavcodec/h264_loopfilter.c
===================================================================
--- libavcodec/h264_loopfilter.c	(revision 25549)
+++ libavcodec/h264_loopfilter.c	(working copy)
@@ -344,10 +344,12 @@
         if(left_type)
             filter_mb_edgev( &img_y[4*0], linesize, bS4, qp0, h);
         if( IS_8x8DCT(mb_type) ) {
+            FFMPEG_METRICS_EXTRACT(s->avctx->metrics.deblock_edges += 4);
             filter_mb_edgev( &img_y[4*2], linesize, bS3, qp, h);
             filter_mb_edgeh( &img_y[4*0*linesize], linesize, bSH, qp1, h);
             filter_mb_edgeh( &img_y[4*2*linesize], linesize, bS3, qp, h);
         } else {
+            FFMPEG_METRICS_EXTRACT(s->avctx->metrics.deblock_edges += 8);
             filter_mb_edgev( &img_y[4*1], linesize, bS3, qp, h);
             filter_mb_edgev( &img_y[4*2], linesize, bS3, qp, h);
             filter_mb_edgev( &img_y[4*3], linesize, bS3, qp, h);
@@ -391,6 +393,7 @@
 
 #define FILTER(hv,dir,edge)\
         if(AV_RN64A(bS[dir][edge])) {                                   \
+			FFMPEG_METRICS_EXTRACT(s->avctx->metrics.deblock_edges++);\
             filter_mb_edge##hv( &img_y[4*edge*(dir?linesize:1)], linesize, bS[dir][edge], edge ? qp : qp##dir, h );\
             if(!(edge&1)) {\
                 filter_mb_edgec##hv( &img_cb[2*edge*(dir?uvlinesize:1)], uvlinesize, bS[dir][edge], edge ? qpc : qpc##dir, h );\
@@ -500,6 +503,7 @@
                 qp = ( s->current_picture.qscale_table[mb_xy] + s->current_picture.qscale_table[mbn_xy] + 1 ) >> 1;
                 tprintf(s->avctx, "filter mb:%d/%d dir:%d edge:%d, QPy:%d ls:%d uvls:%d", mb_x, mb_y, dir, edge, qp, tmp_linesize, tmp_uvlinesize);
                 { int i; for (i = 0; i < 4; i++) tprintf(s->avctx, " bS[%d]:%d", i, bS[i]); tprintf(s->avctx, "\n"); }
+				FFMPEG_METRICS_EXTRACT(s->avctx->metrics.deblock_edges++);
                 filter_mb_edgeh( &img_y[j*linesize], tmp_linesize, bS, qp, h );
                 filter_mb_edgech( &img_cb[j*uvlinesize], tmp_uvlinesize, bS,
                                 ( h->chroma_qp[0] + get_chroma_qp( h, 0, s->current_picture.qscale_table[mbn_xy] ) + 1 ) >> 1, h);
@@ -559,6 +563,7 @@
                 //tprintf(s->avctx, "filter mb:%d/%d dir:%d edge:%d, QPy:%d, QPc:%d, QPcn:%d\n", mb_x, mb_y, dir, edge, qp, h->chroma_qp[0], s->current_picture.qscale_table[mbn_xy]);
                 tprintf(s->avctx, "filter mb:%d/%d dir:%d edge:%d, QPy:%d ls:%d uvls:%d", mb_x, mb_y, dir, edge, qp, linesize, uvlinesize);
                 //{ int i; for (i = 0; i < 4; i++) tprintf(s->avctx, " bS[%d]:%d", i, bS[i]); tprintf(s->avctx, "\n"); }
+				FFMPEG_METRICS_EXTRACT(s->avctx->metrics.deblock_edges++);
                 if( dir == 0 ) {
                     filter_mb_edgev( &img_y[0], linesize, bS, qp, h );
                     {
@@ -637,6 +642,7 @@
         //tprintf(s->avctx, "filter mb:%d/%d dir:%d edge:%d, QPy:%d, QPc:%d, QPcn:%d\n", mb_x, mb_y, dir, edge, qp, h->chroma_qp[0], s->current_picture.qscale_table[mbn_xy]);
         tprintf(s->avctx, "filter mb:%d/%d dir:%d edge:%d, QPy:%d ls:%d uvls:%d", mb_x, mb_y, dir, edge, qp, linesize, uvlinesize);
         //{ int i; for (i = 0; i < 4; i++) tprintf(s->avctx, " bS[%d]:%d", i, bS[i]); tprintf(s->avctx, "\n"); }
+        FFMPEG_METRICS_EXTRACT(s->avctx->metrics.deblock_edges++);
         if( dir == 0 ) {
             filter_mb_edgev( &img_y[4*edge], linesize, bS, qp, h );
             if( (edge&1) == 0 ) {
Index: Makefile
===================================================================
--- Makefile	(revision 25549)
+++ Makefile	(working copy)
@@ -94,15 +94,15 @@
 
 ffplay.o: CFLAGS += $(SDL_CFLAGS)
 
-VERSION_SH  = $(SRC_PATH_BARE)/version.sh
-GIT_LOG     = $(SRC_PATH_BARE)/.git/logs/HEAD
-SVN_ENTRIES = $(SRC_PATH_BARE)/.svn/entries
+VERSION_SH  = version.sh
+GIT_LOG     = .git/logs/HEAD
+SVN_ENTRIES = .svn/entries
 
 .version: $(wildcard $(GIT_LOG) $(SVN_ENTRIES)) $(VERSION_SH) config.mak
 .version: M=@
 
 version.h .version:
-	$(M)$(VERSION_SH) $(SRC_PATH) version.h $(EXTRA_VERSION)
+	$(M)./$(VERSION_SH) $(SRC_PATH) version.h $(EXTRA_VERSION)
 	$(Q)touch .version
 
 # force version.sh to run whenever version might have changed
